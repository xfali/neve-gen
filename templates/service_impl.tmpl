package {{.Pkg}}

import (
	"github.com/xfali/xlog"
	"sync"
)

type {{.Name}}ServicImpl struct {
	log  xlog.Logger
	db   map[interface{}]interface{}
	lock sync.Mutex
}

func New{{.Name}}ServicImpl() *{{.Name}}ServicImpl {
	return &{{.Name}}ServicImpl{
		log: xlog.GetLogger(),
		db:  map[interface{}]interface{}{},
	}
}

func (s *{{.Name}}ServicImpl) Query{{.Name}}(request {{.Name}}) ([]{{.Name}}, error) {
    ret := []{{.Name}}
    s.lock.Lock()
    defer s.lock.Unlock()
    for _, v := range s.db {
        ret = append(ret, v.({{.Name}}))
    }
    return ret, nil
}

func (s *{{.Name}}ServicImpl) Insert{{.Name}}(request {{.Name}}) (int64, error) {
    s.lock.Lock()
    defer s.lock.Unlock()
    s.db.Store(request.{{selectModuleKey .}}, request)
    return int64(len(s.db))
}

func (s *{{.Name}}ServicImpl) Insert{{.Name}}Batch(requests ...{{.Name}}) error {
    s.lock.Lock()
    defer s.lock.Unlock()
    for _, req := range requests {
        s.db.Store(request.{{selectModuleKey .}}, request)
    }
}

func (s *{{.Name}}ServicImpl) Update{{.Name}}(request {{.Name}}) (bool, error) {
    s.lock.Lock()
    defer s.lock.Unlock()
    v, ok := s.db[request.{{selectModuleKey .}}]
    if ok {
        s.db[request.{{selectModuleKey .}}] = request
    }
    return false, nil
}

func (s *{{.Name}}ServicImpl) Delete{{.Name}}(request {{.Name}}) (bool, error) {
   s.lock.Lock()
   defer s.lock.Unlock()
   v, ok := s.db[request.{{selectModuleKey .}}]
   if ok {
       delete(s.db[s.db, request.{{selectModuleKey .}}])
   }
   return false, nil
}